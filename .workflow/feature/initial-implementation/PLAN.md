# PLAN.md - xlq Implementation

**Generated By**: Planner Agent
**Generated At**: 2026-01-23
**Project Type**: Backend CLI/MCP Tool (Go)
**Status**: Ready for Development

## 1. Executive Summary

**xlq** is a streaming xlsx CLI/MCP tool that provides "jq for Excel" functionality. The implementation follows a streaming-first architecture to maintain <100MB memory footprint regardless of file size, using the excelize streaming API and an LRU cache for shared strings.

**Key Architectural Decisions:**
- Pure Go (no CGO) for maximum portability
- Streaming-only operations to ensure bounded memory
- Dual-mode operation: CLI and MCP server via same core
- JSON-first output (token-efficient for AI agents)
- Go-style error handling throughout

## 2. Requirements Mapping

| Requirement | Implementation Component |
|-------------|-------------------------|
| List sheets | `cmd/sheets.go` → `internal/xlsx/reader.go` |
| Sheet metadata | `cmd/info.go` → `internal/xlsx/reader.go` |
| Read cell range | `cmd/read.go` → `internal/xlsx/stream.go` |
| Head N rows | `cmd/head.go` → `internal/xlsx/stream.go` |
| Tail N rows | `cmd/tail.go` → `internal/xlsx/stream.go` |
| Search pattern | `cmd/search.go` → `internal/xlsx/search.go` |
| Get cell value | `cmd/cell.go` → `internal/xlsx/reader.go` |
| MCP server mode | `cmd/mcp.go` → `internal/mcp/server.go` |
| JSON/CSV/TSV output | `internal/output/formatter.go` |
| Memory-bounded streaming | `internal/xlsx/stream.go` + `internal/cache/lru.go` |

## 3. Technical Architecture

### 3.1 Component Diagram

```
┌─────────────────────────────────────────────────────────┐
│                    CLI Entry Point                       │
│                    (cmd/xlq/main.go)                     │
└─────────────────┬───────────────────────────────────────┘
                  │
      ┌───────────┴───────────┐
      │                       │
┌─────▼──────┐        ┌──────▼──────┐
│ CLI Mode   │        │  MCP Mode   │
│ (cmd/*.go) │        │ (cmd/mcp.go)│
└─────┬──────┘        └──────┬──────┘
      │                      │
      └──────────┬───────────┘
                 │
        ┌────────▼────────┐
        │   Core Logic    │
        │ (internal/*)    │
        └────────┬────────┘
                 │
    ┌────────────┼────────────┐
    │            │            │
┌───▼───┐  ┌────▼────┐  ┌───▼────┐
│ XLSX  │  │ Output  │  │ Cache  │
│Reader │  │Formatter│  │ (LRU)  │
└───┬───┘  └─────────┘  └────────┘
    │
┌───▼──────────────┐
│ excelize/v2      │
│ (streaming API)  │
└──────────────────┘
```

### 3.2 Data Flow

**CLI Mode:**
```
User Command → CLI Parser → Core Logic → Streaming Reader → Output Formatter → stdout
```

**MCP Mode:**
```
JSON-RPC stdin → MCP Server → Core Logic → Streaming Reader → JSON Response → stdout
```

### 3.3 Memory Management Strategy

1. **Streaming Reader**: Use `excelize.Rows()` - never load entire sheet
2. **LRU Cache**: Bounded cache for shared strings (max 10,000 entries, ~10MB)
3. **Row Buffering**: For tail operation, ring buffer of N rows only
4. **No Global State**: Each operation is isolated, garbage collected after completion

### 3.4 Tech Stack

| Component | Technology | Version |
|-----------|-----------|---------|
| Language | Go | 1.21+ |
| xlsx Library | github.com/qax-os/excelize/v2 | v2.8.0+ |
| MCP SDK | github.com/modelcontextprotocol/go-sdk | latest |
| CLI Framework | github.com/spf13/cobra | v1.8.0 |
| Testing | stdlib testing + testify | - |

## 4. Project Structure

```
excelize-mcp/
├── cmd/
│   └── xlq/
│       └── main.go                 # Entry point (CLI router)
├── internal/
│   ├── xlsx/
│   │   ├── reader.go               # File/sheet operations (sheets, info, cell)
│   │   ├── stream.go               # Streaming operations (read, head, tail)
│   │   ├── search.go               # Search implementation
│   │   └── types.go                # Common types (CellRange, SheetInfo, etc.)
│   ├── cache/
│   │   └── lru.go                  # LRU cache for shared strings
│   ├── output/
│   │   └── formatter.go            # JSON/CSV/TSV output formatting
│   ├── mcp/
│   │   ├── server.go               # MCP server implementation
│   │   └── handlers.go             # MCP tool handlers
│   └── cli/
│       ├── sheets.go               # sheets command
│       ├── info.go                 # info command
│       ├── read.go                 # read command
│       ├── head.go                 # head command
│       ├── tail.go                 # tail command
│       ├── search.go               # search command
│       ├── cell.go                 # cell command
│       └── root.go                 # root command + flags
├── go.mod
├── go.sum
├── README.md
├── CLAUDE.md                        # Project conventions
├── Makefile                         # build, test, install targets
└── .gitignore
```

## 5. Implementation Tasks

### Phase 1: Foundation & Core Types (1-2 days)

**Priority: Critical** | **Estimated: 5 story points**

- [ ] **Task 1.1**: Initialize Go module and dependencies
  - `go mod init github.com/fuabioo/xlq`
  - Add excelize, cobra, MCP SDK dependencies
  - Create go.sum
  - **Estimate**: 1 story point

- [ ] **Task 1.2**: Create project structure
  - Create all directories (cmd, internal/*)
  - Add .gitignore (vendor/, dist/, *.xlsx)
  - Create initial CLAUDE.md with conventions
  - **Estimate**: 1 story point

- [ ] **Task 1.3**: Implement core types (`internal/xlsx/types.go`)
  - `CellRange` type with parser (A1:B10 → struct)
  - `SheetInfo` struct (name, rows, cols, headers)
  - `Cell` struct (address, value, type)
  - Error types (ErrInvalidRange, ErrSheetNotFound, etc.)
  - **Estimate**: 2 story points

- [ ] **Task 1.4**: Implement LRU cache (`internal/cache/lru.go`)
  - Generic LRU cache with size bound
  - Thread-safe access (sync.RWMutex)
  - Eviction policy (least recently used)
  - Unit tests
  - **Estimate**: 3 story points

### Phase 2: XLSX Core Operations (3-4 days)

**Priority: Critical** | **Estimated: 13 story points**

- [ ] **Task 2.1**: Reader foundation (`internal/xlsx/reader.go`)
  - `OpenFile(path string) (*excelize.File, error)`
  - `GetSheets(file *excelize.File) ([]string, error)`
  - `GetSheetInfo(file, sheet string) (*SheetInfo, error)` - streaming row count
  - `GetCell(file, sheet, addr string) (*Cell, error)`
  - Error handling with context
  - **Estimate**: 3 story points

- [ ] **Task 2.2**: Streaming operations (`internal/xlsx/stream.go`)
  - `StreamRange(file, sheet, rangeStr string) (<-chan Cell, error)` - channel-based
  - `StreamHead(file, sheet string, n int) (<-chan Cell, error)`
  - `StreamTail(file, sheet string, n int) ([]Cell, error)` - ring buffer
  - Shared string cache integration
  - **Estimate**: 5 story points

- [ ] **Task 2.3**: Search implementation (`internal/xlsx/search.go`)
  - `Search(file, pattern string) (<-chan SearchResult, error)` - all sheets
  - Regex support (compile once, reuse)
  - Case-insensitive option
  - Stream through all sheets
  - **Estimate**: 3 story points

- [ ] **Task 2.4**: Output formatter (`internal/output/formatter.go`)
  - `FormatJSON(data interface{}) ([]byte, error)`
  - `FormatCSV(rows [][]string) ([]byte, error)`
  - `FormatTSV(rows [][]string) ([]byte, error)`
  - Writer interface for streaming output
  - **Estimate**: 2 story points

### Phase 3: CLI Interface (2-3 days)

**Priority: High** | **Estimated: 8 story points**

- [ ] **Task 3.1**: Root command setup (`internal/cli/root.go`)
  - Cobra root command initialization
  - Global flags: --format (json|csv|tsv), --help
  - Version command
  - Error handling wrapper
  - **Estimate**: 2 story points

- [ ] **Task 3.2**: Basic commands (`internal/cli/{sheets,info,cell}.go`)
  - `sheets` command implementation
  - `info` command implementation (sheet optional)
  - `cell` command implementation (sheet + address)
  - Wire up to internal/xlsx/reader.go
  - **Estimate**: 2 story points

- [ ] **Task 3.3**: Streaming commands (`internal/cli/{read,head,tail}.go`)
  - `read` command (file, sheet, range)
  - `head` command (file, sheet, -n flag)
  - `tail` command (file, sheet, -n flag)
  - Wire up to internal/xlsx/stream.go
  - **Estimate**: 2 story points

- [ ] **Task 3.4**: Search command (`internal/cli/search.go`)
  - `search` command (file, pattern)
  - Optional flags: -i (case-insensitive), --sheet (limit to sheet)
  - Progress indicator for large files
  - **Estimate**: 2 story points

- [ ] **Task 3.5**: Main entry point (`cmd/xlq/main.go`)
  - Initialize CLI app
  - Route to MCP mode if --mcp flag
  - Exit code handling
  - **Estimate**: 1 story point

### Phase 4: MCP Server Integration (2-3 days)

**Priority: High** | **Estimated: 8 story points**

- [ ] **Task 4.1**: MCP server foundation (`internal/mcp/server.go`)
  - Initialize MCP server with stdio transport
  - Server lifecycle management
  - Tool registration
  - Error response formatting
  - **Estimate**: 3 story points

- [ ] **Task 4.2**: MCP tool handlers (`internal/mcp/handlers.go`)
  - Map each CLI command to MCP tool
  - JSON schema definitions for each tool
  - Input validation
  - Call internal/xlsx/* functions
  - **Estimate**: 3 story points

- [ ] **Task 4.3**: MCP mode integration (`internal/cli/mcp.go` or update root)
  - Add --mcp flag to root command
  - Launch MCP server instead of CLI
  - Graceful shutdown handling
  - **Estimate**: 2 story points

### Phase 5: Testing & Documentation (2-3 days)

**Priority: Medium** | **Estimated: 8 story points**

- [ ] **Task 5.1**: Unit tests
  - `internal/xlsx/*_test.go` - core logic tests
  - `internal/cache/lru_test.go` - cache behavior
  - `internal/output/formatter_test.go` - output formats
  - Test fixtures (small .xlsx files)
  - **Estimate**: 3 story points

- [ ] **Task 5.2**: Integration tests
  - CLI command tests (cobra testing framework)
  - End-to-end tests with real xlsx files
  - Memory profiling tests (<100MB assertion)
  - **Estimate**: 3 story points

- [ ] **Task 5.3**: Documentation
  - README.md (installation, usage, examples)
  - CLAUDE.md (project conventions, architecture)
  - Inline code documentation (godoc)
  - MCP tool descriptions
  - **Estimate**: 2 story points

### Phase 6: Build & Distribution (1 day)

**Priority: Medium** | **Estimated: 3 story points**

- [ ] **Task 6.1**: Build system (`Makefile`)
  - `make build` - build binary
  - `make test` - run tests
  - `make install` - install to $GOPATH/bin
  - `make clean` - cleanup
  - **Estimate**: 1 story point

- [ ] **Task 6.2**: CI/CD setup (optional, if needed)
  - GitHub Actions workflow
  - Test on push/PR
  - Release binary artifacts
  - **Estimate**: 2 story points

## 6. File-by-File Implementation Details

### 6.1 Core Types (`internal/xlsx/types.go`)

**Purpose**: Common types and parsing logic
**Estimated LOC**: ~150 lines

```go
package xlsx

// Key types
type CellRange struct {
    StartCol, StartRow int
    EndCol, EndRow     int
}

type SheetInfo struct {
    Name    string
    Rows    int
    Cols    int
    Headers []string
}

type Cell struct {
    Address string
    Value   string
    Type    string // number, string, bool, formula, error
}

type SearchResult struct {
    Sheet   string
    Address string
    Value   string
}

// Key functions
func ParseRange(rangeStr string) (*CellRange, error)
func ParseCellAddress(addr string) (col, row int, err error)
func FormatCellAddress(col, row int) string
```

**Dependencies**: None (stdlib only)
**Testing**: Unit tests for range parsing, address conversion

---

### 6.2 LRU Cache (`internal/cache/lru.go`)

**Purpose**: Memory-bounded cache for shared strings
**Estimated LOC**: ~120 lines

```go
package cache

import "sync"

type LRU struct {
    mu       sync.RWMutex
    capacity int
    items    map[string]*node
    head     *node
    tail     *node
}

func New(capacity int) *LRU
func (c *LRU) Get(key string) (string, bool)
func (c *LRU) Set(key, value string)
func (c *LRU) evict()
```

**Dependencies**: stdlib only
**Testing**: Concurrent access tests, eviction policy tests

---

### 6.3 Reader Operations (`internal/xlsx/reader.go`)

**Purpose**: Non-streaming file/sheet operations
**Estimated LOC**: ~200 lines

```go
package xlsx

import "github.com/qax-os/excelize/v2"

// Key functions
func OpenFile(path string) (*excelize.File, error) {
    // Open file, validate format
    // Return excelize.File handle
}

func GetSheets(f *excelize.File) ([]string, error) {
    // Return list of sheet names
}

func GetSheetInfo(f *excelize.File, sheet string) (*SheetInfo, error) {
    // Stream through rows to count
    // Detect headers (first row)
    // Calculate dimensions
}

func GetCell(f *excelize.File, sheet, addr string) (*Cell, error) {
    // Get single cell value
    // Detect type
    // Return Cell struct
}
```

**Dependencies**: excelize/v2
**Testing**: Test with various xlsx files, missing sheets, invalid addresses

---

### 6.4 Streaming Operations (`internal/xlsx/stream.go`)

**Purpose**: Memory-efficient streaming reads
**Estimated LOC**: ~250 lines

```go
package xlsx

import (
    "github.com/qax-os/excelize/v2"
    "your-module/internal/cache"
)

var sharedStringCache = cache.New(10000) // Global cache

func StreamRange(f *excelize.File, sheet, rangeStr string, format string) (<-chan Cell, error) {
    // Parse range
    // Open streaming rows
    // Channel-based output
    // Use cache for shared strings
}

func StreamHead(f *excelize.File, sheet string, n int, format string) (<-chan Cell, error) {
    // Stream first N rows
    // Early termination
}

func StreamTail(f *excelize.File, sheet string, n int, format string) ([]Cell, error) {
    // Ring buffer of N rows
    // Stream entire sheet, keep last N
    // Return buffered rows
}
```

**Dependencies**: excelize/v2, internal/cache
**Testing**: Large file tests (>100MB), memory profiling

---

### 6.5 Search (`internal/xlsx/search.go`)

**Purpose**: Pattern matching across sheets
**Estimated LOC**: ~150 lines

```go
package xlsx

import (
    "regexp"
    "github.com/qax-os/excelize/v2"
)

func Search(f *excelize.File, pattern string, caseInsensitive bool, sheet string) (<-chan SearchResult, error) {
    // Compile regex once
    // If sheet specified, search only that sheet
    // Else iterate all sheets
    // Stream through rows
    // Yield matches on channel
}
```

**Dependencies**: excelize/v2, regexp
**Testing**: Test regex patterns, case sensitivity, multi-sheet

---

### 6.6 Output Formatter (`internal/output/formatter.go`)

**Purpose**: Format data as JSON/CSV/TSV
**Estimated LOC**: ~180 lines

```go
package output

import (
    "encoding/json"
    "encoding/csv"
)

type Formatter interface {
    Format(data interface{}) ([]byte, error)
}

type JSONFormatter struct{}
type CSVFormatter struct{}
type TSVFormatter struct{}

func NewFormatter(format string) (Formatter, error)

// JSON: use stdlib encoding/json
// CSV: use encoding/csv with proper escaping
// TSV: similar to CSV but tab-delimited
```

**Dependencies**: stdlib only
**Testing**: Test all formats, special chars, empty data

---

### 6.7 CLI Commands (`internal/cli/*.go`)

**Purpose**: Cobra command implementations
**Estimated LOC**: ~400 lines total (7 files x ~60 lines each)

Each command file follows this pattern:

```go
package cli

import (
    "github.com/spf13/cobra"
    "your-module/internal/xlsx"
    "your-module/internal/output"
)

var sheetsCmd = &cobra.Command{
    Use:   "sheets <file.xlsx>",
    Short: "List all sheets in workbook",
    Args:  cobra.ExactArgs(1),
    RunE:  runSheets,
}

func runSheets(cmd *cobra.Command, args []string) error {
    // Open file
    // Call xlsx.GetSheets()
    // Format output
    // Print to stdout
    // Handle errors
}

func init() {
    rootCmd.AddCommand(sheetsCmd)
}
```

**Files**: root.go, sheets.go, info.go, read.go, head.go, tail.go, search.go, cell.go
**Dependencies**: cobra, internal/xlsx, internal/output
**Testing**: Cobra test framework, mock xlsx operations

---

### 6.8 MCP Server (`internal/mcp/server.go`)

**Purpose**: MCP server implementation
**Estimated LOC**: ~200 lines

```go
package mcp

import (
    "github.com/modelcontextprotocol/go-sdk/server"
)

type Server struct {
    mcp *server.MCPServer
}

func NewServer() (*Server, error) {
    // Initialize MCP server with stdio transport
    // Register all tools
    // Set up error handlers
}

func (s *Server) Start() error {
    // Start server loop
    // Handle shutdown signals
}
```

**Dependencies**: go-sdk
**Testing**: Integration tests with MCP client

---

### 6.9 MCP Handlers (`internal/mcp/handlers.go`)

**Purpose**: Map CLI operations to MCP tools
**Estimated LOC**: ~300 lines

```go
package mcp

import (
    "your-module/internal/xlsx"
)

// Tool definitions
var toolSheets = Tool{
    Name: "sheets",
    Description: "List all sheets in an Excel file",
    InputSchema: {...},
}

// Handler functions
func (s *Server) handleSheets(params map[string]interface{}) (interface{}, error) {
    // Extract file path from params
    // Call xlsx.GetSheets()
    // Return JSON response
}

// Similar for: info, read, head, tail, search, cell
```

**Dependencies**: internal/xlsx, go-sdk
**Testing**: Unit tests for each handler

---

### 6.10 Main Entry Point (`cmd/xlq/main.go`)

**Purpose**: Application entry point
**Estimated LOC**: ~50 lines

```go
package main

import (
    "os"
    "your-module/internal/cli"
    "your-module/internal/mcp"
)

func main() {
    // Check for --mcp flag early
    if isMCPMode() {
        runMCP()
        return
    }

    // Otherwise run CLI
    if err := cli.Execute(); err != nil {
        os.Exit(1)
    }
}

func isMCPMode() bool {
    // Check os.Args for --mcp
}

func runMCP() {
    // Start MCP server
}
```

**Dependencies**: internal/cli, internal/mcp
**Testing**: Integration tests

---

## 7. Testing Strategy

### 7.1 Unit Tests

| Package | Test Coverage Target | Key Test Cases |
|---------|---------------------|----------------|
| internal/xlsx | >85% | Range parsing, cell address conversion, edge cases |
| internal/cache | >90% | Eviction, concurrency, capacity limits |
| internal/output | >80% | All formats, special characters, empty data |

### 7.2 Integration Tests

- CLI command execution with real xlsx files
- MCP server communication via stdio
- Memory profiling with large files (verify <100MB)
- Error handling (missing files, invalid sheets)

### 7.3 Test Fixtures

Create test xlsx files:
- `testdata/small.xlsx` - 3 sheets, <100 rows (basic tests)
- `testdata/large.xlsx` - 1 sheet, 100k rows (streaming tests)
- `testdata/unicode.xlsx` - Unicode characters, special chars
- `testdata/formulas.xlsx` - Formula cells, references

## 8. Performance Targets

| Metric | Target | Measurement Method |
|--------|--------|-------------------|
| Memory usage | <100MB | `go test -memprofile` with 100k row file |
| Startup time | <100ms | Time to first output for small file |
| Streaming throughput | >10k rows/sec | Benchmark on large file |
| Build time | <10s | `time make build` |
| Binary size | <15MB | `ls -lh` on built binary |

## 9. Dependencies

```go
// go.mod
module github.com/fuabioo/xlq

go 1.21

require (
    github.com/qax-os/excelize/v2 v2.8.1
    github.com/spf13/cobra v1.8.0
    github.com/modelcontextprotocol/go-sdk v0.1.0 // Check latest version
    github.com/stretchr/testify v1.9.0 // For testing
)
```

## 10. Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Excelize memory leaks | Medium | High | Extensive profiling, streaming API only |
| MCP SDK immaturity | Medium | Medium | Version pinning, integration tests |
| Large file edge cases | High | Medium | Comprehensive test suite with large files |
| Shared string cache inefficiency | Low | Medium | Benchmarking, configurable cache size |
| Cross-platform compatibility | Low | Low | CI testing on Linux/macOS/Windows |

## 11. Development Timeline

**Total Estimated Effort**: ~45 story points (~3.5 weeks for 1 developer)

| Phase | Duration | Story Points |
|-------|----------|--------------|
| Phase 1: Foundation | 2 days | 5 |
| Phase 2: XLSX Core | 4 days | 13 |
| Phase 3: CLI | 3 days | 8 |
| Phase 4: MCP Server | 3 days | 8 |
| Phase 5: Testing | 3 days | 8 |
| Phase 6: Build/Docs | 1 day | 3 |

## 12. Success Criteria

- [ ] All CLI commands work with test files
- [ ] MCP server responds to all defined tools
- [ ] Memory usage stays <100MB for 100k row file
- [ ] Unit test coverage >80%
- [ ] README with installation and usage examples
- [ ] Binary builds successfully on Linux/macOS

## 13. Future Enhancements (Post-MVP)

- Write operations (update cells, create sheets)
- Column filtering/projection (read only columns A,C,E)
- Row filtering (WHERE-like conditions)
- Aggregations (SUM, AVG, COUNT per column)
- Multi-file operations (merge, diff)
- Excel formula evaluation
- Export to other formats (Parquet, SQLite)

---

## Next Steps

1. Review this plan for completeness
2. Initialize Go module and dependencies (Phase 1, Task 1.1)
3. Create project structure (Phase 1, Task 1.2)
4. Begin implementation with Phase 1 tasks
5. After each phase, run tests and validate memory usage

**Ready to begin implementation.**
