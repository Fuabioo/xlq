# PLAN.md - XLSX Edit Capabilities for xlq

**Generated By**: Planner Agent
**Generated At**: 2026-01-28
**Project Type**: Backend CLI Tool
**Status**: Ready for Development

---

## 1. Executive Summary

This plan adds write/edit capabilities to xlq, transforming it from a read-only tool into a full-featured Excel manipulation tool for AI agents. The implementation leverages excelize's write APIs while maintaining the project's streaming-first philosophy where possible.

**Key Design Decisions:**
1. **Atomic Operations**: Each write tool is self-contained (open, modify, save, close)
2. **No In-Memory Session State**: Unlike reads, writes require loading the file, so we embrace this constraint
3. **Safe Defaults**: Backup original files, validate paths strictly, prevent overwrites unless explicit
4. **StreamWriter for Large Inserts**: Use excelize StreamWriter when appending many rows to new sheets

---

## 2. AI Agent Use Cases (Priority Order)

| Priority | Use Case | Description | Tool(s) |
|----------|----------|-------------|---------|
| P0 | Update single cell | Fix a typo, update a value | `write_cell` |
| P0 | Add data rows | Append new records to existing sheet | `append_rows` |
| P0 | Create new file | Start fresh Excel workbook | `create_file` |
| P1 | Update range | Bulk update multiple cells | `write_range` |
| P1 | Add new sheet | Add worksheet to existing file | `create_sheet` |
| P1 | Delete sheet | Remove unwanted worksheet | `delete_sheet` |
| P2 | Insert rows | Insert rows at specific position | `insert_rows` |
| P2 | Delete rows | Remove specific rows | `delete_rows` |
| P2 | Rename sheet | Change sheet name | `rename_sheet` |
| P3 | Copy file | Save as new file (template workflow) | `copy_file` |

---

## 3. Technical Architecture

### 3.1 Memory Constraints Analysis

**Key Insight**: Unlike reads, xlsx writes CANNOT be streamed for existing files.

| Operation | Memory Model | Rationale |
|-----------|--------------|-----------|
| `write_cell` | Load entire file | Must preserve existing data |
| `append_rows` | Load entire file | Must know last row position |
| `write_range` | Load entire file | Must preserve surrounding data |
| `create_file` | Minimal | New file, StreamWriter possible |
| `create_sheet` | Load entire file | Add to existing workbook |
| `insert_rows` | Load entire file | Shift existing data |

**Memory Mitigation Strategies:**
1. Set file size limits for write operations (e.g., max 50MB input file)
2. Limit batch write sizes (e.g., max 10,000 cells per operation)
3. Close files immediately after write
4. Document memory implications for users

### 3.2 Component Diagram

```
                                 xlq
                                  |
                    +-------------+-------------+
                    |                           |
               CLI Commands                MCP Tools
                    |                           |
                    +-------------+-------------+
                                  |
                         internal/xlsx/
                                  |
                    +-------------+-------------+
                    |                           |
              reader.go (existing)       writer.go (NEW)
              stream.go (existing)       writer_stream.go (NEW - for create_file)
              types.go (existing)
```

### 3.3 New Package Structure

```
internal/xlsx/
    writer.go           # Core write functions
    writer_types.go     # Write-related types and errors
    writer_test.go      # Unit tests

internal/mcp/
    server.go           # Add write tool handlers
    security.go         # Add write path validation
    limits.go           # Add write limits
```

### 3.4 Security Model for Writes

Write operations require stricter security than reads:

```go
// security.go additions
func ValidateWritePath(requestedPath string, allowOverwrite bool) (string, error) {
    // 1. Path validation (existing)
    // 2. Check if file exists (if not allowOverwrite, require new file)
    // 3. Check parent directory is writable
    // 4. Prevent writing to sensitive locations
    // 5. Prevent path traversal
}

// Blocked paths for writes (even if in allowed base)
var blockedWritePaths = []string{
    ".git/",
    "node_modules/",
    ".env",
    "*.key",
    "*.pem",
}
```

---

## 4. Proposed MCP Tools

### 4.1 write_cell - Write Single Cell Value

**Schema:**
```json
{
  "name": "write_cell",
  "description": "Write a value to a specific cell in an Excel file",
  "inputSchema": {
    "type": "object",
    "required": ["file", "cell", "value"],
    "properties": {
      "file": {
        "type": "string",
        "description": "Path to xlsx file"
      },
      "sheet": {
        "type": "string",
        "description": "Sheet name (default: first sheet)"
      },
      "cell": {
        "type": "string",
        "description": "Cell address (e.g., A1, B23)"
      },
      "value": {
        "type": ["string", "number", "boolean"],
        "description": "Value to write"
      },
      "type": {
        "type": "string",
        "enum": ["auto", "string", "number", "bool", "formula"],
        "description": "Value type (default: auto-detect)"
      }
    }
  }
}
```

**Response:**
```json
{
  "success": true,
  "cell": "A1",
  "previous_value": "old",
  "new_value": "new"
}
```

### 4.2 append_rows - Append Rows to Sheet

**Schema:**
```json
{
  "name": "append_rows",
  "description": "Append one or more rows to the end of a sheet (max 1000 rows per call)",
  "inputSchema": {
    "type": "object",
    "required": ["file", "rows"],
    "properties": {
      "file": {
        "type": "string",
        "description": "Path to xlsx file"
      },
      "sheet": {
        "type": "string",
        "description": "Sheet name (default: first sheet)"
      },
      "rows": {
        "type": "array",
        "description": "Array of rows to append",
        "items": {
          "type": "array",
          "items": {
            "type": ["string", "number", "boolean", "null"]
          }
        },
        "maxItems": 1000
      }
    }
  }
}
```

**Response:**
```json
{
  "success": true,
  "rows_added": 5,
  "starting_row": 101,
  "ending_row": 105
}
```

### 4.3 create_file - Create New Excel File

**Schema:**
```json
{
  "name": "create_file",
  "description": "Create a new Excel file with optional initial data",
  "inputSchema": {
    "type": "object",
    "required": ["file"],
    "properties": {
      "file": {
        "type": "string",
        "description": "Path for new xlsx file"
      },
      "sheet_name": {
        "type": "string",
        "description": "Name of first sheet (default: Sheet1)"
      },
      "headers": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Optional header row"
      },
      "rows": {
        "type": "array",
        "description": "Optional initial data rows",
        "items": {
          "type": "array",
          "items": {
            "type": ["string", "number", "boolean", "null"]
          }
        },
        "maxItems": 10000
      },
      "overwrite": {
        "type": "boolean",
        "description": "Allow overwriting existing file (default: false)"
      }
    }
  }
}
```

### 4.4 write_range - Write Multiple Cells

**Schema:**
```json
{
  "name": "write_range",
  "description": "Write values to a range of cells (max 10000 cells)",
  "inputSchema": {
    "type": "object",
    "required": ["file", "start_cell", "data"],
    "properties": {
      "file": {
        "type": "string",
        "description": "Path to xlsx file"
      },
      "sheet": {
        "type": "string",
        "description": "Sheet name (default: first sheet)"
      },
      "start_cell": {
        "type": "string",
        "description": "Top-left cell of range (e.g., A1)"
      },
      "data": {
        "type": "array",
        "description": "2D array of values (rows x columns)",
        "items": {
          "type": "array",
          "items": {
            "type": ["string", "number", "boolean", "null"]
          }
        }
      }
    }
  }
}
```

### 4.5 create_sheet - Create New Sheet

**Schema:**
```json
{
  "name": "create_sheet",
  "description": "Create a new sheet in an existing workbook",
  "inputSchema": {
    "type": "object",
    "required": ["file", "name"],
    "properties": {
      "file": {
        "type": "string",
        "description": "Path to xlsx file"
      },
      "name": {
        "type": "string",
        "description": "Name for new sheet"
      },
      "headers": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Optional header row"
      }
    }
  }
}
```

### 4.6 delete_sheet - Delete Sheet

**Schema:**
```json
{
  "name": "delete_sheet",
  "description": "Delete a sheet from workbook (cannot delete last sheet)",
  "inputSchema": {
    "type": "object",
    "required": ["file", "sheet"],
    "properties": {
      "file": {
        "type": "string",
        "description": "Path to xlsx file"
      },
      "sheet": {
        "type": "string",
        "description": "Sheet name to delete"
      }
    }
  }
}
```

### 4.7 insert_rows - Insert Rows at Position

**Schema:**
```json
{
  "name": "insert_rows",
  "description": "Insert rows at a specific position, shifting existing rows down",
  "inputSchema": {
    "type": "object",
    "required": ["file", "row", "data"],
    "properties": {
      "file": {
        "type": "string",
        "description": "Path to xlsx file"
      },
      "sheet": {
        "type": "string",
        "description": "Sheet name (default: first sheet)"
      },
      "row": {
        "type": "number",
        "description": "Row number to insert at (1-based)"
      },
      "data": {
        "type": "array",
        "description": "Rows to insert",
        "items": {
          "type": "array",
          "items": {
            "type": ["string", "number", "boolean", "null"]
          }
        },
        "maxItems": 1000
      }
    }
  }
}
```

### 4.8 delete_rows - Delete Rows

**Schema:**
```json
{
  "name": "delete_rows",
  "description": "Delete rows from sheet",
  "inputSchema": {
    "type": "object",
    "required": ["file", "start_row", "count"],
    "properties": {
      "file": {
        "type": "string",
        "description": "Path to xlsx file"
      },
      "sheet": {
        "type": "string",
        "description": "Sheet name (default: first sheet)"
      },
      "start_row": {
        "type": "number",
        "description": "First row to delete (1-based)"
      },
      "count": {
        "type": "number",
        "description": "Number of rows to delete (max 1000)"
      }
    }
  }
}
```

### 4.9 rename_sheet - Rename Sheet

**Schema:**
```json
{
  "name": "rename_sheet",
  "description": "Rename a sheet in workbook",
  "inputSchema": {
    "type": "object",
    "required": ["file", "old_name", "new_name"],
    "properties": {
      "file": {
        "type": "string",
        "description": "Path to xlsx file"
      },
      "old_name": {
        "type": "string",
        "description": "Current sheet name"
      },
      "new_name": {
        "type": "string",
        "description": "New sheet name"
      }
    }
  }
}
```

---

## 5. Implementation Tasks

### Phase 1: Foundation (Estimate: 5 story points, ~2.5 days)

Core infrastructure for write operations.

- [ ] **Task 1.1**: Create `internal/xlsx/writer_types.go` (1 pt)
  - Define WriteResult, WriteError types
  - Define write operation constants (limits, defaults)
  - Add error types: ErrFileExists, ErrWriteDenied, ErrFileTooLarge

- [ ] **Task 1.2**: Extend security in `internal/mcp/security.go` (2 pts)
  - Add `ValidateWritePath()` function
  - Implement blocked paths list
  - Add file size validation for writes
  - Add directory writability check

- [ ] **Task 1.3**: Create `internal/xlsx/writer.go` base (2 pts)
  - Implement `OpenFileForWrite()` - opens file for modification
  - Implement `SaveFile()` - saves and closes file
  - Implement helper: `setCellWithType()` - writes cell with type detection

### Phase 2: Core Write Tools (Estimate: 8 story points, ~4 days)

The most commonly needed write operations.

- [ ] **Task 2.1**: Implement `WriteCell()` in writer.go (2 pts)
  - Open file, write single cell, save
  - Support auto type detection
  - Return previous value for confirmation

- [ ] **Task 2.2**: Implement `AppendRows()` in writer.go (2 pts)
  - Find last row using streaming (memory efficient)
  - Write new rows starting at last+1
  - Enforce row limit (1000)

- [ ] **Task 2.3**: Implement `CreateFile()` in writer.go (2 pts)
  - Use `excelize.NewFile()`
  - Use `StreamWriter` for initial data (memory efficient)
  - Handle overwrite flag

- [ ] **Task 2.4**: Register MCP tools for Phase 2 (2 pts)
  - Add `write_cell` handler to server.go
  - Add `append_rows` handler to server.go
  - Add `create_file` handler to server.go

### Phase 3: Bulk Operations (Estimate: 5 story points, ~2.5 days)

Range operations and sheet management.

- [ ] **Task 3.1**: Implement `WriteRange()` (2 pts)
  - Parse start cell, calculate bounds
  - Iterate and write each cell
  - Enforce cell limit (10,000)

- [ ] **Task 3.2**: Implement sheet management functions (2 pts)
  - `CreateSheet()` - use `f.NewSheet()`
  - `DeleteSheet()` - use `f.DeleteSheet()`
  - `RenameSheet()` - use `f.SetSheetName()`

- [ ] **Task 3.3**: Register MCP tools for Phase 3 (1 pt)
  - Add `write_range`, `create_sheet`, `delete_sheet`, `rename_sheet`

### Phase 4: Row Operations (Estimate: 5 story points, ~2.5 days)

Insert and delete rows with existing data shift.

- [ ] **Task 4.1**: Implement `InsertRows()` (2 pts)
  - Use `f.InsertRows()` to shift existing
  - Write new data at insertion point
  - Handle formula references (excelize handles this)

- [ ] **Task 4.2**: Implement `DeleteRows()` (1 pt)
  - Use `f.RemoveRow()` in loop
  - Validate row exists

- [ ] **Task 4.3**: Register MCP tools for Phase 4 (1 pt)
  - Add `insert_rows`, `delete_rows` handlers

- [ ] **Task 4.4**: Unit tests for all write operations (1 pt)
  - Test each function with valid input
  - Test error conditions
  - Test edge cases (empty file, large batch)

### Phase 5: CLI Commands (Estimate: 3 story points, ~1.5 days)

Add CLI equivalents for MCP tools.

- [ ] **Task 5.1**: Create `internal/cli/write.go` (2 pts)
  - `xlq write <file> <cell> <value>` - write single cell
  - `xlq write <file> --sheet <sheet> --range A1 --input data.json`

- [ ] **Task 5.2**: Create `internal/cli/create.go` (1 pt)
  - `xlq create <file> [--sheet name] [--headers h1,h2]`

### Phase 6: Documentation & Polish (Estimate: 2 story points, ~1 day)

- [ ] **Task 6.1**: Update CLAUDE.md with write conventions (0.5 pt)
- [ ] **Task 6.2**: Update README with new commands (0.5 pt)
- [ ] **Task 6.3**: Add integration tests (1 pt)

---

## 6. Risk Assessment

### 6.1 Technical Risks

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Memory issues with large files | Medium | High | Enforce file size limits, document constraints |
| Data corruption on partial writes | Low | Critical | Use temp file + atomic rename pattern |
| Path traversal attacks | Low | Critical | Strict path validation, symlink resolution |
| Formula corruption | Low | Medium | Rely on excelize's built-in handling |
| Concurrent access conflicts | Medium | Medium | Document single-writer limitation |

### 6.2 Atomic Write Pattern

To prevent corruption, implement atomic writes:

```go
func SaveFileAtomic(f *excelize.File, path string) error {
    // 1. Save to temp file in same directory
    tempPath := path + ".tmp"
    if err := f.SaveAs(tempPath); err != nil {
        return err
    }

    // 2. Rename temp to target (atomic on most filesystems)
    if err := os.Rename(tempPath, path); err != nil {
        os.Remove(tempPath) // Cleanup on failure
        return err
    }

    return nil
}
```

### 6.3 Memory Budget

Given the <100MB target:
- **Max input file size**: 50MB (leaves room for in-memory processing)
- **Max rows per append**: 1,000 rows
- **Max cells per write_range**: 10,000 cells
- **Max initial rows for create_file**: 10,000 rows

---

## 7. Testing Strategy

### 7.1 Unit Tests (writer_test.go)

```go
func TestWriteCell(t *testing.T)           // Basic write
func TestWriteCellTypes(t *testing.T)      // String, number, bool, formula
func TestAppendRows(t *testing.T)          // Append to existing
func TestAppendRowsEmpty(t *testing.T)     // Append to empty sheet
func TestAppendRowsLimit(t *testing.T)     // Enforce 1000 row limit
func TestCreateFile(t *testing.T)          // New file creation
func TestCreateFileOverwrite(t *testing.T) // Overwrite behavior
func TestWriteRange(t *testing.T)          // Bulk write
func TestWriteRangeLimit(t *testing.T)     // Enforce cell limit
func TestCreateSheet(t *testing.T)         // Add sheet
func TestDeleteSheet(t *testing.T)         // Remove sheet
func TestDeleteLastSheet(t *testing.T)     // Error case
func TestInsertRows(t *testing.T)          // Insert with shift
func TestDeleteRows(t *testing.T)          // Remove rows
```

### 7.2 Security Tests (security_test.go additions)

```go
func TestValidateWritePath(t *testing.T)
func TestWritePathBlocked(t *testing.T)     // .git, .env, etc.
func TestWritePathTraversal(t *testing.T)   // ../../../etc
func TestWritePathSymlink(t *testing.T)     // Symlink attacks
```

### 7.3 Integration Tests

```go
func TestMCPWriteCell(t *testing.T)
func TestMCPAppendRows(t *testing.T)
func TestMCPCreateFile(t *testing.T)
// ... for each MCP tool
```

---

## 8. Implementation Order Summary

```
Week 1: Phase 1 + Phase 2 (Foundation + Core Tools)
        - Infrastructure
        - write_cell, append_rows, create_file

Week 2: Phase 3 + Phase 4 (Bulk + Row Operations)
        - write_range, sheet management
        - insert_rows, delete_rows

Week 3: Phase 5 + Phase 6 (CLI + Polish)
        - CLI commands
        - Documentation, tests
```

**Total Estimate**: 28 story points (~14 days / ~3 weeks with buffer)

---

## 9. Success Criteria

1. All MCP write tools pass integration tests
2. Memory stays <100MB for files up to 50MB
3. No data corruption in stress tests (100 concurrent writes)
4. CLI commands mirror MCP tool functionality
5. Security tests pass (no path traversal, no blocked path writes)
6. Documentation updated with examples

---

## 10. Future Considerations (Out of Scope)

- **Styling**: Add cell formatting (bold, colors, borders)
- **Formulas**: Build formulas programmatically
- **Charts**: Create charts from data
- **Pivot Tables**: Generate pivot tables
- **Conditional Formatting**: Apply conditional rules
- **Concurrent Writes**: Multi-writer with locking (complex)
