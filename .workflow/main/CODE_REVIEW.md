# CODE_REVIEW.md

**Generated By**: Reviewer Agent
**Generated At**: 2026-01-23
**Project Type**: Backend CLI Tool (Go)
**Skills Applied**: backend.md
**Files Reviewed**: All Go source files in repository
**Status**: Approved with Minor Suggestions

---

## Summary

The xlq codebase is a well-structured Go CLI tool and MCP server for streaming Excel file operations. The architecture correctly implements streaming patterns, follows Go idioms, and provides clean separation of concerns. The codebase demonstrates strong fundamentals with consistent error handling, proper resource cleanup, and well-designed APIs.

**Strengths:**
- Streaming-first architecture properly implemented
- Consistent Go-style error handling throughout
- Clean package separation (cli, xlsx, cache, output, mcp)
- Good test coverage for core functionality
- Proper use of channels for async streaming
- Ring buffer implementation for tail operations is elegant
- LRU cache is thread-safe and well-tested
- MCP safety limits prevent context exhaustion

**Areas for Improvement:**
- Unused LRU cache (implemented but not integrated)
- MCP server handler tests are limited
- Some minor inconsistencies in error handling patterns
- Missing integration tests for CLI commands

---

## Critical Issues (Must Fix)

None identified. The codebase is production-ready.

---

## Major Suggestions (Should Fix)

| File | Line | Category | Issue | Recommendation |
|------|------|----------|-------|----------------|
| `/home/fuabioo/Playground/excelize-mcp/internal/cache/lru.go` | - | Unused Code | LRU cache is implemented and tested but never used in the codebase | Either integrate the LRU cache into shared string handling (as suggested in CLAUDE.md) or document it as a future optimization |
| `/home/fuabioo/Playground/excelize-mcp/internal/mcp/server.go` | 97-356 | Test Coverage | MCP handlers have only 13.4% coverage - handlers are tested indirectly but lack unit tests | Add unit tests for individual handlers using test fixtures |
| `/home/fuabioo/Playground/excelize-mcp/go.mod` | 4 | Compatibility | `go 1.25.6` is a future version (Go 1.24 is latest stable as of Jan 2026) | Verify this is intentional; consider using `go 1.23` for broader compatibility |
| `/home/fuabioo/Playground/excelize-mcp/internal/cli/root.go` | 12 | Global State | `formatFlag` as package-level variable with `GetFormat()` accessor creates hidden global state | Consider refactoring to pass format through command context or cobra command annotations |

---

## Minor Suggestions (Could Fix)

| File | Line | Issue | Suggestion |
|------|------|-------|------------|
| `/home/fuabioo/Playground/excelize-mcp/internal/xlsx/types.go` | 174-177 | Unused Function | `IsValidRange()` has 0% coverage and appears unused | Either use it or remove it; currently only tested indirectly via ParseRange |
| `/home/fuabioo/Playground/excelize-mcp/internal/xlsx/reader.go` | 156-201 | Low Coverage | `detectCellType()` has 43.5% coverage; many branches untested | Add tests for formula detection and different cell types |
| `/home/fuabioo/Playground/excelize-mcp/internal/cli/sheets.go` | 27-33 | Error Shadowing | Calling FormatSingle after GetSheets - if GetSheets returns a sheet list and then FormatSingle fails, user gets no useful output | Consider logging the sheets data before formatting fails, or restructure flow |
| `/home/fuabioo/Playground/excelize-mcp/internal/output/formatter.go` | 189-210 | Inconsistent Map Handling | `toStringSlice()` iterates map values in non-deterministic order | Document this limitation or use sorted keys for deterministic output |
| `/home/fuabioo/Playground/excelize-mcp/internal/mcp/server.go` | 180 | Dead Code | `totalScanned` is captured but immediately discarded with `_ = totalScanned` | Either use the value for logging/debugging or simplify the call |
| `/home/fuabioo/Playground/excelize-mcp/cmd/xlq/main.go` | 11-15 | Documentation | Build-time variables are undocumented | Add comments explaining these are set by goreleaser/ldflags |

---

## Test Coverage Assessment

**Overall Coverage: 68.8%**

| Package | Coverage | Assessment |
|---------|----------|------------|
| `internal/cache` | 96.0% | Excellent - LRU fully tested |
| `internal/xlsx` | 86.4% | Good - core streaming logic well-covered |
| `internal/output` | 80.9% | Good - formatters tested |
| `internal/cli` | 67.3% | Acceptable - basic command tests exist |
| `internal/mcp` | 13.4% | Low - handlers need more coverage |
| `cmd/xlq` | 0.0% | Expected - main() not unit-testable |

**Testing Quality:**
- Table-driven tests used appropriately
- Edge cases covered (empty sheets, invalid ranges, nil files)
- Benchmarks included for performance-critical paths
- Uses `t.Helper()` correctly in test helpers
- Proper cleanup with `defer` in tests

**Gaps:**
1. No end-to-end integration tests for CLI
2. MCP handlers tested only via helper functions, not actual MCP calls
3. No tests for concurrent access patterns in real-world scenarios

---

## Streaming Architecture Adherence

**Verdict: Properly Implemented**

The codebase correctly adheres to streaming principles:

1. **Uses `excelize.Rows()` iterator**: All row reading uses the streaming iterator, never `GetRows()` which loads all data.

2. **Channel-based streaming**: `StreamRows()`, `StreamRange()`, and `Search()` return channels that yield results incrementally.

3. **Ring buffer for tail**: `StreamTail()` correctly uses a fixed-size ring buffer to maintain bounded memory regardless of file size.

4. **Early termination**: When limits are reached (max results, row limits), iteration stops immediately.

5. **Proper cleanup**: All iterators are closed with `defer rows.Close()`.

---

## Memory Management Assessment

**Verdict: Well-Designed**

1. **LRU Cache**: Properly implements bounded LRU with O(1) operations (though currently unused).

2. **Ring Buffer**: `StreamTail()` uses fixed-size buffer `make([]Row, n)` - memory bounded by user-specified limit.

3. **MCP Safety Limits**: Output size capped at 5MB, rows capped at sensible defaults (1000-5000).

4. **File Handle Management**: All `excelize.File` handles properly closed with defer.

5. **Channel Patterns**: Channels are closed in goroutines with defer, no goroutine leaks.

---

## API Design Consistency

**CLI and MCP Tool Mapping:**

| CLI Command | MCP Tool | Consistent? |
|-------------|----------|-------------|
| `xlq sheets <file>` | `sheets(file)` | Yes |
| `xlq info <file> [sheet]` | `info(file, sheet?)` | Yes |
| `xlq read <file> [sheet] [range]` | `read(file, sheet?, range?)` | Yes |
| `xlq head <file> [sheet] -n N` | `head(file, sheet?, n?)` | Yes |
| `xlq tail <file> [sheet] -n N` | `tail(file, sheet?, n?)` | Yes |
| `xlq search <file> <pattern> [flags]` | `search(file, pattern, ...)` | Yes |
| `xlq cell <file> [sheet] <addr>` | `cell(file, address, sheet?)` | Yes |

The APIs are consistent. Minor note: CLI puts address last for `cell`, MCP puts it before sheet - both are valid ergonomic choices for their contexts.

---

## SOLID Principles Check

**S - Single Responsibility**: Good. Each package has clear purpose.
- `xlsx/` - Excel file operations
- `cli/` - Command definitions
- `mcp/` - MCP server logic
- `cache/` - Caching infrastructure
- `output/` - Output formatting

**O - Open/Closed**: The `Formatter` interface allows new output formats without modifying existing code.

**L - Liskov Substitution**: N/A - no inheritance used.

**I - Interface Segregation**: `Formatter` interface is appropriately focused (FormatValue, FormatSlice, streaming methods).

**D - Dependency Inversion**: CLI commands depend on `xlsx` package abstractions, not concrete implementations.

---

## Security Considerations

1. **Path Handling**: No path traversal vulnerabilities - paths taken directly from user input without manipulation.

2. **Regex DoS**: Regex patterns are user-controlled. Consider adding a timeout or complexity limit for regex compilation (not currently implemented but low risk for CLI tool).

3. **Output Size**: MCP output capped at 5MB - prevents memory exhaustion attacks.

4. **No Sensitive Data Exposure**: Tool only reads files, no network operations or credential handling.

---

## Positive Observations

1. **Excellent streaming design** - The channel-based streaming with `RowResult` wrapping both rows and errors is idiomatic Go.

2. **Well-documented CLAUDE.md** - The project documentation clearly states architecture decisions and coding conventions.

3. **Clean error messages** - Errors wrap context with `fmt.Errorf("...: %w", err)` consistently.

4. **Good use of table-driven tests** - Test cases are readable and maintainable.

5. **Smart defaults** - The MCP server has sensible limits that prevent accidental context exhaustion.

6. **Case-insensitive sheet matching** - User-friendly sheet name resolution with `strings.EqualFold`.

7. **Range normalization** - `ParseRange()` normalizes reversed ranges (D5:B2 -> B2:D5), preventing user errors.

8. **Build automation** - goreleaser config for cross-platform builds, justfile for development workflow.

---

## Recommendations Summary

1. **Integrate or document LRU cache** - It's well-implemented but sitting unused.

2. **Add MCP handler unit tests** - Current 13.4% coverage is a gap.

3. **Review Go version in go.mod** - `go 1.25.6` may be unintentional.

4. **Consider refactoring global formatFlag** - Pass through command context for cleaner design.

5. **Add integration tests** - End-to-end CLI tests would catch flag parsing and output issues.

---

*This review was generated by analyzing all Go source files, tests, and documentation in the repository.*
